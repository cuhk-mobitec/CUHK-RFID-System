/*
 * Generated by XDoclet - Do not edit!
 */
package cuhk.ale.valueobjects;

/**
 * Value object for ECSpecInstance.
 *
 * Notice, this object is used to represent the state of an 
 * ECSpecInstance object. This value object
 * Is not connected to the database in any way, it is just a normal object used 
 * as a container for data from an EJB. 
 *
 * @xdoclet-generated at ${TODAY}
 * @copyright The XDoclet Team
 * @author XDoclet
 * @version ${version}
 */
public class ECSpecInstanceValue
   extends java.lang.Object
   implements java.io.Serializable, java.lang.Cloneable 
{

   private java.lang.String specName;
   private boolean specNameHasBeenSet = false;

   private long startTime;
   private boolean startTimeHasBeenSet = false;

   private long previousStartTime;
   private boolean previousStartTimeHasBeenSet = false;

   private long previousEndTime;
   private boolean previousEndTimeHasBeenSet = false;

   private int stateVersion;
   private boolean stateVersionHasBeenSet = false;

   private epcglobal.ale.ECSpec ECSpec;
   private boolean ECSpecHasBeenSet = false;

   private int state;
   private boolean stateHasBeenSet = false;

   private cuhk.ale.ejb.interfaces.ECSpecInstancePK primaryKey;

   public ECSpecInstanceValue()
   {
	  primaryKey = new cuhk.ale.ejb.interfaces.ECSpecInstancePK();
   }

   public ECSpecInstanceValue( java.lang.String specName,long startTime,long previousStartTime,long previousEndTime,int stateVersion,epcglobal.ale.ECSpec ECSpec,int state )
   {
       setSpecName(specName);
       setStartTime(startTime);
       setPreviousStartTime(previousStartTime);
       setPreviousEndTime(previousEndTime);
       setStateVersion(stateVersion);
       setECSpec(ECSpec);
       setState(state);
       primaryKey = new cuhk.ale.ejb.interfaces.ECSpecInstancePK(this.getSpecName());
   }

   /**
    * @deprecated use {@link #clone}
    */
   public ECSpecInstanceValue( ECSpecInstanceValue otherValue )
   {
	  this.specName = otherValue.specName;
	  specNameHasBeenSet = true;
	  this.startTime = otherValue.startTime;
	  startTimeHasBeenSet = true;
	  this.previousStartTime = otherValue.previousStartTime;
	  previousStartTimeHasBeenSet = true;
	  this.previousEndTime = otherValue.previousEndTime;
	  previousEndTimeHasBeenSet = true;
	  this.stateVersion = otherValue.stateVersion;
	  stateVersionHasBeenSet = true;
	  this.ECSpec = otherValue.ECSpec;
	  ECSpecHasBeenSet = true;
	  this.state = otherValue.state;
	  stateHasBeenSet = true;

	  primaryKey = new cuhk.ale.ejb.interfaces.ECSpecInstancePK(this.getSpecName());
   }

   public cuhk.ale.ejb.interfaces.ECSpecInstancePK getPrimaryKey()
   {
	  return primaryKey;
   }

   public void setPrimaryKey( cuhk.ale.ejb.interfaces.ECSpecInstancePK primaryKey)
   {
      // it's also nice to update PK object - just in case
      // somebody would ask for it later...
      this.primaryKey = primaryKey;
	  setSpecName( primaryKey.specName );
   }

   public java.lang.String getSpecName()
   {
	  return this.specName;
   }

   public void setSpecName( java.lang.String specName )
   {
	  this.specName = specName;
	  specNameHasBeenSet = true;

      primaryKey.setSpecName(specName);
   }

   public boolean specNameHasBeenSet(){
	  return specNameHasBeenSet;
   }
   public long getStartTime()
   {
	  return this.startTime;
   }

   public void setStartTime( long startTime )
   {
	  this.startTime = startTime;
	  startTimeHasBeenSet = true;

   }

   public boolean startTimeHasBeenSet(){
	  return startTimeHasBeenSet;
   }
   public long getPreviousStartTime()
   {
	  return this.previousStartTime;
   }

   public void setPreviousStartTime( long previousStartTime )
   {
	  this.previousStartTime = previousStartTime;
	  previousStartTimeHasBeenSet = true;

   }

   public boolean previousStartTimeHasBeenSet(){
	  return previousStartTimeHasBeenSet;
   }
   public long getPreviousEndTime()
   {
	  return this.previousEndTime;
   }

   public void setPreviousEndTime( long previousEndTime )
   {
	  this.previousEndTime = previousEndTime;
	  previousEndTimeHasBeenSet = true;

   }

   public boolean previousEndTimeHasBeenSet(){
	  return previousEndTimeHasBeenSet;
   }
   public int getStateVersion()
   {
	  return this.stateVersion;
   }

   public void setStateVersion( int stateVersion )
   {
	  this.stateVersion = stateVersion;
	  stateVersionHasBeenSet = true;

   }

   public boolean stateVersionHasBeenSet(){
	  return stateVersionHasBeenSet;
   }
   public epcglobal.ale.ECSpec getECSpec()
   {
	  return this.ECSpec;
   }

   public void setECSpec( epcglobal.ale.ECSpec ECSpec )
   {
	  this.ECSpec = ECSpec;
	  ECSpecHasBeenSet = true;

   }

   public boolean ECSpecHasBeenSet(){
	  return ECSpecHasBeenSet;
   }
   public int getState()
   {
	  return this.state;
   }

   public void setState( int state )
   {
	  this.state = state;
	  stateHasBeenSet = true;

   }

   public boolean stateHasBeenSet(){
	  return stateHasBeenSet;
   }

   public String toString()
   {
	  StringBuffer str = new StringBuffer("{");

	  str.append("specName=" + getSpecName() + " " + "startTime=" + getStartTime() + " " + "previousStartTime=" + getPreviousStartTime() + " " + "previousEndTime=" + getPreviousEndTime() + " " + "stateVersion=" + getStateVersion() + " " + "ECSpec=" + getECSpec() + " " + "state=" + getState());
	  str.append('}');

	  return(str.toString());
   }

   /**
    * A Value Object has an identity if the attributes making its Primary Key have all been set. An object without identity is never equal to any other object.
    *
    * @return true if this instance has an identity.
    */
   protected boolean hasIdentity()
   {
	  boolean ret = true;
	  ret = ret && specNameHasBeenSet;
	  return ret;
   }

   /**
    *
    * @deprecated use {@link #equals}
    */
   public boolean isIdentical(Object other)
   {
          if (other instanceof ECSpecInstanceValue)
          {
                 ECSpecInstanceValue that = (ECSpecInstanceValue) other;
                 boolean lEquals = true;
                 lEquals = lEquals && this.startTime == that.startTime;
                 lEquals = lEquals && this.previousStartTime == that.previousStartTime;
                 lEquals = lEquals && this.previousEndTime == that.previousEndTime;
                 lEquals = lEquals && this.stateVersion == that.stateVersion;
                 if( this.ECSpec == null )
                 {
                        lEquals = lEquals && ( that.ECSpec == null );
                 }
                 else
                 {
                        lEquals = lEquals && this.ECSpec.equals( that.ECSpec );
                 }
                 lEquals = lEquals && this.state == that.state;

                 return lEquals;
          }
          else
          {
                 return false;
          }
   }

    public boolean equals(Object other) {

        //If it's not the correct type, clearly it isn't equal to this.
        if (!(other instanceof ECSpecInstanceValue)) { 
            return false;
        }

        return equals((ECSpecInstanceValue) other);
    }

    /**
     * This class is not using strict ordering. This means that the object is not Comparable, and
     * each check for equality will test all members for equality. We do not check collections for
     * equality however, so you would be wise to not use this if you have collection typed EJB References.
     */
    public boolean equals(ECSpecInstanceValue that) {

        //try to get lucky.
        if (this == that) {
            return true;
        }
        //this clearly isn't null.
        if(null == that) {
            return false;
        }

        if(this.specName != that.specName) {

            if( this.specName == null || that.specName == null ) {
                return false;
            }

            if(!this.specName.equals(that.specName)) {
                return false;
            }

        }

        if(this.startTime != that.startTime) {
            return false;
        }

        if(this.previousStartTime != that.previousStartTime) {
            return false;
        }

        if(this.previousEndTime != that.previousEndTime) {
            return false;
        }

        if(this.stateVersion != that.stateVersion) {
            return false;
        }

        if(this.ECSpec != that.ECSpec) {

            if( this.ECSpec == null || that.ECSpec == null ) {
                return false;
            }

            if(!this.ECSpec.equals(that.ECSpec)) {
                return false;
            }

        }

        if(this.state != that.state) {
            return false;
        }

        return true;

    }

    public Object clone() throws java.lang.CloneNotSupportedException {
        ECSpecInstanceValue other = (ECSpecInstanceValue) super.clone();

        return other;
    }

    public ReadOnlyECSpecInstanceValue getReadOnlyECSpecInstanceValue() {
        return new ReadOnlyECSpecInstanceValue();
    }

    public int hashCode(){
	  int result = 17;
      result = 37*result + ((this.specName != null) ? this.specName.hashCode() : 0);

      result = 37*result + (int)(startTime^(startTime>>>32));

      result = 37*result + (int)(previousStartTime^(previousStartTime>>>32));

      result = 37*result + (int)(previousEndTime^(previousEndTime>>>32));

      result = 37*result + (int) stateVersion;

      result = 37*result + ((this.ECSpec != null) ? this.ECSpec.hashCode() : 0);

      result = 37*result + (int) state;

	  return result;
    }

    /**
     * Covariant function so the compiler can choose the proper one at compile time,
     * eliminates the need for XDoclet to really understand compiletime typing.
     *
     * Read only collections need to be synchronized. Once we start giving out handles
     * to these collections, they'll be used in other threads sooner or later. 
     */
    private static java.util.Collection wrapCollection(java.util.Collection input) {
        return java.util.Collections.synchronizedCollection(input);
    }
    /**
     * Covariant function so the compiler can choose the proper one at compile time,
     * eliminates the need for XDoclet to really understand compiletime typing.
     *
     * Read only collections need to be synchronized. Once we start giving out handles
     * to these collections, they'll be used in other threads sooner or later. 
     */
    private static java.util.Set wrapCollection(java.util.Set input) {
        return java.util.Collections.synchronizedSet(input);
    }
    /**
     * Covariant function. This is used in covariant form so that the compiler
     * can do some of our conditional branches for us. If I made these functions
     * have different names, then XDoclet would have to choose between them based on 
     * compiletime types, that wouldn't be easy. 
     */
    private static java.util.Collection wrapReadOnly(java.util.Collection input) {
        return java.util.Collections.unmodifiableCollection(input);
    }
    /**
     * Covariant function. This is used in covariant form so that the compiler
     * can do some of our conditional branches for us. If I made these functions
     * have different names, then XDoclet would have to choose between them based on 
     * compiletime types, that wouldn't be easy. 
     */
    private static java.util.Set wrapReadOnly(java.util.Set input) {
        return java.util.Collections.unmodifiableSet(input);
    }

    private final class ReadOnlyECSpecInstanceValue 
    implements java.lang.Cloneable, java.io.Serializable 
    {
        private ECSpecInstanceValue underlying() {
            return ECSpecInstanceValue.this;
        }

       public java.lang.String getSpecName() {
              return underlying().specName;
       }

       public long getStartTime() {
              return underlying().startTime;
       }

       public long getPreviousStartTime() {
              return underlying().previousStartTime;
       }

       public long getPreviousEndTime() {
              return underlying().previousEndTime;
       }

       public int getStateVersion() {
              return underlying().stateVersion;
       }

       public epcglobal.ale.ECSpec getECSpec() {
              return underlying().ECSpec;
       }

       public int getState() {
              return underlying().state;
       }

        public int hashCode() {
            return 101 * underlying().hashCode();
        }

        public boolean equals(Object o) {
            if(o instanceof ReadOnlyECSpecInstanceValue) {
                return this.equals((ReadOnlyECSpecInstanceValue) o);
            }
            return false;
        }

        public boolean equals(ReadOnlyECSpecInstanceValue that) {
            if(null == that) {
                return false;
            }

            return this.underlying().equals(that.underlying());
        }

    }

}
